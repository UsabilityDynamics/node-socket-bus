<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/sockets/sock.js - WebSocket MQ</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://a3d72a45d111006ec192-ec5b80a12b0b09b4d52373336afb4254.r80.cf1.rackcdn.com/usability-dynamics.png" title="WebSocket MQ"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib/sockets/sock.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

/**
 * Module dependencies.
 */

var net = require(&#x27;net&#x27;)
  , Parser = require(&#x27;../parser&#x27;)
  , Message = require(&#x27;../message&#x27;)
  , codecs = require(&#x27;../codecs&#x27;)
  , Emitter = require(&#x27;events&#x27;).EventEmitter
  , debug = require(&#x27;debug&#x27;)(&#x27;axon:sock&#x27;)
  , Configurable = require(&#x27;configurable&#x27;)
  , url = require(&#x27;url&#x27;);

/**
 * Errors to ignore.
 */

var ignore = [
  &#x27;ECONNREFUSED&#x27;,
  &#x27;ECONNRESET&#x27;,
  &#x27;ETIMEDOUT&#x27;,
  &#x27;EHOSTUNREACH&#x27;,
  &#x27;ENETUNREACH&#x27;,
  &#x27;ENETDOWN&#x27;,
  &#x27;EPIPE&#x27;
];

/**
 * Expose &#x60;Socket&#x60;.
 */

module.exports = Socket;

/**
 * Initialize a new &#x60;Socket&#x60;.
 *
 * A &quot;Socket&quot; encapsulates the ability of being
 * the &quot;client&quot; or the &quot;server&quot; depending on
 * whether &#x60;connect()&#x60; or &#x60;bind()&#x60; was called.
 *
 * Upon sending and recieving messages, the correct codec
 * set by &#x60;format&#x60; will be applied. Both sides must elect
 * the same codec, or all hell will break loose on the app.
 *
 * @api private
 */

function Socket() {
  var self = this;
  this.opts = {};
  this.server = null;
  this.socks = [];
  this.settings = {};
  this.format(&#x27;none&#x27;);
  this.set(&#x27;hwm&#x27;, Infinity);
  this.set(&#x27;identity&#x27;, String(process.pid));
  this.set(&#x27;retry timeout&#x27;, 100);
  this.set(&#x27;retry max timeout&#x27;, 5000);
}

/**
 * Inherit from &#x60;Emitter.prototype&#x60;.
 */

Socket.prototype.__proto__ = Emitter.prototype;

/**
 * Make it configurable &#x60;.set()&#x60; etc.
 */

Configurable(Socket.prototype);

/**
 * Use the given &#x60;plugin&#x60;.
 *
 * @param {Function} plugin
 * @api private
 */

Socket.prototype.use = function(plugin){
  plugin(this);
  return this;
};

/**
 * Set format to &#x60;type&#x60;.
 *
 * @param {String} type
 * @return {Socket}
 * @api public
 */

Socket.prototype.format = function(type){
  var codec = codecs.byName(type);
  if (!codec) throw new Error(&#x27;unknown format &quot;&#x27; + type + &#x27;&quot;&#x27;);
  this.codec = codec;
  return this;
};


/**
 * Creates a new &#x60;Message&#x60; and writes &#x60;data&#x60; using the
 * &#x60;codec&#x60; set already by &#x60;format&#x60;.
 *
 * This will only work for single part messages or multi
 * part message that all use the same codec. If you need
 * otherwise, use the &#x60;Message&#x60; constructor to craft
 * your own message.
 *
 * @param {Mixed} data
 * @return {Buffer}
 * @api private
 */

Socket.prototype.pack = function(data){
  var msg = new Message
    , codec = this.codec;

  if (Array.isArray(data)) {
    for (var i = 0; i &lt; data.length; i++) {
      msg.write(codec.encode(data[i]), codec.id);
    }
  } else {
    msg.write(codec.encode(data), codec.id);
  }

  return msg.toBuffer();
};

/**
 * Close all open underlying sockets.
 *
 * @api private
 */

Socket.prototype.closeSockets = function(){
  debug(&#x27;closing %d connections&#x27;, this.socks.length);
  this.socks.forEach(function(sock){
    sock.destroy();
  });
};

/**
 * Close the socket.
 *
 * Delegates to the server or clients
 * based on the socket &#x60;type&#x60;.
 *
 * @param {Function} [fn]
 * @api public
 */

Socket.prototype.close = function(fn){
  debug(&#x27;closing&#x27;);
  this.closing = true;
  this.closeSockets();
  if (this.server) this.closeServer(fn);
};

/**
 * Close the server.
 *
 * @param {Function} [fn]
 * @api public
 */

Socket.prototype.closeServer = function(fn){
  debug(&#x27;closing server&#x27;);
  this.server.on(&#x27;close&#x27;, this.emit.bind(this, &#x27;close&#x27;));
  this.server.close();
  fn &amp;&amp; fn();
};

/**
 * Return the server address.
 *
 * @return {Object}
 * @api public
 */

Socket.prototype.address = function(){
  if (!this.server) return;
  var addr = this.server.address();
  addr.string = &#x27;tcp://&#x27; + addr.address + &#x27;:&#x27; + addr.port;
  return addr;
};

/**
 * Remove &#x60;sock&#x60;.
 *
 * @param {Socket} sock
 * @api private
 */

Socket.prototype.removeSocket = function(sock){
  var i = this.socks.indexOf(sock);
  if (!~i) return;
  debug(&#x27;remove socket %d&#x27;, i);
  this.socks.splice(i, 1);
};

/**
 * Add &#x60;sock&#x60;.
 *
 * @param {Socket} sock
 * @api private
 */

Socket.prototype.addSocket = function(sock){
  var parser = new Parser;
  var i = this.socks.push(sock) - 1;
  debug(&#x27;add socket %d&#x27;, i);
  sock.on(&#x27;data&#x27;, parser.write.bind(parser));
  parser.onmessage = this.onmessage(sock);
};

/**
 * Handle &#x60;sock&#x60; errors.
 *
 * Emits:
 *
 *  - &#x60;error&#x60; (err) when the error is not ignored
 *  - &#x60;ignored error&#x60; (err) when the error is ignored
 *  - &#x60;socket error&#x60; (err) regardless of ignoring
 *
 * @param {Socket} sock
 * @api private
 */

Socket.prototype.handleErrors = function(sock){
  var self = this;
  sock.on(&#x27;error&#x27;, function(err){
    debug(&#x27;error %s&#x27;, err.code || err.message);
    self.emit(&#x27;socket error&#x27;, err);
    self.removeSocket(sock);
    if (!~ignore.indexOf(err.code)) return self.emit(&#x27;error&#x27;, err);
    debug(&#x27;ignored %s&#x27;, err.code);
    self.emit(&#x27;ignored error&#x27;, err);
  });
};

/**
 * Handles framed messages emitted from the parser, by
 * default it will go ahead and emit the &quot;message&quot; events on
 * the socket. However, if the &quot;higher level&quot; socket needs
 * to hook into the messages before they are emitted, it
 * should override this method and take care of everything
 * it self, including emitted the &quot;message&quot; event.
 *
 * @param {net.Socket} sock
 * @return {Function} closure(msg, mulitpart)
 * @api private
 */

Socket.prototype.onmessage = function(sock){
  var self = this;
  return function(msg, multipart){
    if (multipart) {
      msg.unshift(&#x27;message&#x27;);
      self.emit.apply(self, msg);
    } else {
      self.emit(&#x27;message&#x27;, msg);
    }
  };
};

/**
 * Connect to &#x60;port&#x60; at &#x60;host&#x60; and invoke &#x60;fn()&#x60;.
 *
 * Defaults &#x60;host&#x60; to localhost.
 *
 * @param {Number|String} port
 * @param {String} host
 * @param {Function} fn
 * @return {Socket}
 * @api public
 */

Socket.prototype.connect = function(port, host, fn){
  var self = this;
  if (&#x27;server&#x27; == this.type) throw new Error(&#x27;cannot connect() after bind()&#x27;);
  if (&#x27;function&#x27; == typeof host) fn = host, host = undefined;

  if (&#x27;string&#x27; == typeof port) {
    port = url.parse(port);
    host = port.hostname;
    port = parseInt(port.port, 10);
  }

  var max = self.get(&#x27;retry max timeout&#x27;);
  var sock = new net.Socket;
  sock.setNoDelay();
  this.type = &#x27;client&#x27;;
  port = port;
  host = host || &#x27;127.0.0.1&#x27;;

  this.handleErrors(sock);

  sock.on(&#x27;close&#x27;, function(){
    self.connected = false;
    self.removeSocket(sock);
    if (self.closing) return self.emit(&#x27;close&#x27;);
    var retry = self.retry || self.get(&#x27;retry timeout&#x27;);
    setTimeout(function(){
      debug(&#x27;attempting reconnect&#x27;);
      self.emit(&#x27;reconnect attempt&#x27;);
      sock.destroy();
      self.connect(port, host);
      self.retry = Math.min(max, retry * 1.5);
    }, retry);
  });

  sock.on(&#x27;connect&#x27;, function(){
    debug(&#x27;connect&#x27;);
    self.connected = true;
    self.addSocket(sock);
    self.retry = self.get(&#x27;retry timeout&#x27;);
    self.emit(&#x27;connect&#x27;);
    fn &amp;&amp; fn();
  });

  debug(&#x27;connect attempt %s:%s&#x27;, host, port);
  sock.connect(port, host);
  return this;
};

/**
 * Handle connection.
 *
 * @param {Socket} sock
 * @api private
 */

Socket.prototype.onconnect = function(sock){
  var self = this;
  var addr = sock.remoteAddress + &#x27;:&#x27; + sock.remotePort;
  debug(&#x27;accept %s&#x27;, addr);
  this.addSocket(sock);
  this.handleErrors(sock);
  this.emit(&#x27;connect&#x27;, sock);
  sock.on(&#x27;close&#x27;, function(){
    debug(&#x27;disconnect %s&#x27;, addr);
    self.emit(&#x27;disconnect&#x27;, sock);
    self.removeSocket(sock);
  });
};

/**
 * Bind to &#x60;port&#x60; at &#x60;host&#x60; and invoke &#x60;fn()&#x60;.
 *
 * Defaults &#x60;host&#x60; to INADDR_ANY.
 *
 * Emits:
 *
 *  - &#x60;connection&#x60; when a client connects
 *  - &#x60;disconnect&#x60; when a client disconnects
 *  - &#x60;bind&#x60; when bound and listening
 *
 * @param {Number|String} port
 * @param {Function} fn
 * @return {Socket}
 * @api public
 */

Socket.prototype.bind = function(port, host, fn){
  var self = this;
  if (&#x27;client&#x27; == this.type) throw new Error(&#x27;cannot bind() after connect()&#x27;);
  if (&#x27;function&#x27; == typeof host) fn = host, host = undefined;

  if (&#x27;string&#x27; == typeof port) {
    port = url.parse(port);
    host = port.hostname;
    port = parseInt(port.port, 10);
  }

  this.type = &#x27;server&#x27;;
  host = host || &#x27;0.0.0.0&#x27;;

  this.server = net.createServer(this.onconnect.bind(this));

  debug(&#x27;bind %s:%s&#x27;, host, port);
  this.server.on(&#x27;listening&#x27;, this.emit.bind(this, &#x27;bind&#x27;));
  this.server.listen(port, host, fn);
  return this;
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
